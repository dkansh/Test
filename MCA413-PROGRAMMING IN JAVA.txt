a. Explain any five features of Java: Java is a general-purpose programming language developed with the aim to bring portability and a higher level of security. Other than these two main java features, there are many other features of Java that make it such a unique and popular language. 
  1) Simple: Java is easy to learn and its syntax is quite simple, clean and easy to understand.The confusing and ambiguous concepts of C++ are either left out in Java or they have been re-implemented in a cleaner way.
      Eg : Pointers and Operator Overloading are not there in java but were an important part of C++.
      
  2) Object Oriented: In java everything is Object which has some data and behaviour. Java can be easily extended as it is based on Object Model.
      An Object-oriented programming has the following concepts that the Java language also has-
        Object
        Class
        Inheritance
        Polymorphism
        Abstraction
        Encapsulation
  
  3) Robus: Java makes an effort to eliminate error prone codes by emphasizing mainly on compile time error checking and runtime checking. But the main areas which Java improved were Memory Management and mishandled Exceptions by introducing automatic Garbage Collector and Exception Handling.
  
  4) Platform Independent: Unlike other programming languages such as C, C++ etc which are compiled into platform specific machines. Java is guaranteed to be write-once, run-anywhere language. 
        On compilation Java program is compiled into bytecode. This bytecode is platform independent and can be run on any machine, plus this bytecode format also provide security. Any machine with Java Runtime Environment can run Java Programs.

  5) Secure: When it comes to security, Java is always the first choice. With java secure features it enable us to develop virus free, temper free system. Java program always runs in Java runtime environment with almost null interaction with system OS, hence it is more secure.
  
  
  

b. What is Bytecode? Explain in brief: Bytecode is computer object code that is processed by a program, usually referred to as a virtual machine, rather than by the "real" computer machine, the hardware processor. The virtual machine converts each generalized machine instruction into a specific machine instruction or instructions that this computer's processor will understand. Bytecode is the result of compiling source code written in a language that supports this approach. Most computer languages, such as C and C++, require a separate compiler for each computer platform - that is, for each computer operating system and the hardware set of instructions that it is built on. Windows and the Intel line of microprocessor architectures are one platform; Apple and the PowerPC processors are another. Using a language that comes with a virtual machine for each platform, your source language statements need to be compiled only once and will then run on any platform.
The best-known language today that uses the bytecode and virtual machine approach is Java. The LISP language, used in artificial intelligence applications, is an earlier language that compiled bytecode. Other languages that use bytecode or a similar approach include Icon and Prolog.
Rather than being interpreted one instruction at a time, Java bytecode can be recompiled at each particular system platform by a just-in-time compiler. Usually, this will enable the Java program to run faster. In Java, bytecode is contained in a binary file with a .CLASS suffix.
Java bytecode is the resulting compiled object code of a Java program. This bytecode can be run in any platform which has a Java installation in it.
This machine independence is because of the Java virtual machine that runs the bytecode in proxy of the processor which means that a Java programmer does not have to be knowledgeable about the quirks and nuances about specific operating systems and processors that the program will be run on because the virtual machine takes care of those specifics. 
The Java bytecode is not completely compiled, but rather just an intermediate code sitting in the middle because it still has to be interpreted and executed by the JVM installed on the specific platform such as Windows, Mac or Linux. 
Upon compile, the Java source code is converted into the .class bytecode.






Q2) Differentiate Break and Continue statements in Java with example program.
Ans: Both “break” and “continue” are the ‘jump’ statements, that transfer control of the program to another part of the program. C++ supports four jump statements namely  ‘return’, ‘goto’, ‘break’ and ‘continue’. Java supports three jump statements ‘break’ ‘continue’ and ‘return’. The main difference between break and continue is that break is used for immediate termination of loop whereas, continue terminate current iteration and resumes the control to the next iteration of the loop. Let’s study the difference between break and continue in the context of C++ and Java.
 
 https://techdifferences.com/difference-between-break-and-continue.html
 
 
 Q 3) Differentiate between packages and Interfaces. 
 Ans: https://techdifferences.com/difference-between-packages-and-interfaces-in-java.html
 
 
 
 
 Set 2
 Q 1) List and explain all three components of Event. Explain Event Listener.
 Ans: Any program that uses GUI (graphical user interface) such as Java application written for windows, is event driven. Event describes the change in state of any object. For Example : Pressing a button, Entering a character in Textbox, Clicking or Dragging a mouse, etc.
      A source generates an Event and send it to one or more listeners registered with the source. Once event is received by the listener, they process the event and then return. Events are supported by a number of Java packages, like java.util, java.awt and java.awt.event.
      An event in Java is an object that is created when something changes within a graphical user interface. If a user clicks on a button, clicks on a combo box, or types characters into a text field, etc., then an event triggers, creating the relevant event object. This behavior is part of Java's Event Handling mechanism and is included in the Swing GUI library. 
      For example, let's say we have a JButton. If a user clicks on the JButton, a button click event is triggered, the event will be created, and it will be sent to the relevant event listener (in this case, the ActionListener). The relevant listener will have implemented code that determines the action to take when the event occurs. 
      Note that an event source must be paired with an event listener, or its triggering will result in no action.

      Event handling has three main components,
          Events : An event is a change in state of an object.
          Events Source : Event source is an object that generates an event.
          Listeners : A listener is an object that listens to the event. A listener gets notified when an event occurs.
          
     The Event listener represent the interfaces responsible to handle events. Java provides us various Event listener classes but we will discuss those which are more frequently used. Every method of an event listener method has a single argument as an object which is subclass of EventObject class. For example, mouse event listener methods will accept instance of MouseEvent, where MouseEvent derives from EventObject.
     The event delegation model contains two main components. First are the event sources and second are the listeners. Most of the listener interfaces are available in the java.awt.event package. In Java, there are several event listener interfaces
     An Event Listener, once set to an applet object, waits for some action to be performed on it, be it mouse click, mouse hover, pressing of keys, click of button, etc. The class you are using (e.g. JButton, etc.) reports the activity to a class set by the class using it. That method then decides on how to react because of that action, usually with a series of if statements to determine which action it was performed on. source.getSource() will return the name of the object that the event was performed on, while the source is the object passed to the function when the action is performed. Every single time the action is performed, it calls the method.
     
     
     
     Q 2) What is JDBC? How will you load the ODBC driver?
     Ans: Java Database Connectivity (JDBC) is an application program interface (API) specification for connecting programs written in Java to the data in popular databases. The application program interface lets you encode access request statements in Structured Query Language (SQL) that are then passed to the program that manages the database. It returns the results through a similar interface. JDBC is very similar to the SQL Access Group's Open Database Connectivity (ODBC) and, with a small "bridge" program, you can use the JDBC interface to access databases through the ODBC interface. For example, you could write a program designed to access many popular database products on a number of operating system platforms. When accessing a database on a PC running Microsoft's Windows 2000 and, for example, a Microsoft Access database, your program with JDBC statements would be able to access the Microsoft Access database.
     JDBC actually has two levels of interface. In addition to the main interface, there is also an API from a JDBC "manager" that in turn communicates with individual database product "drivers," the JDBC-ODBC bridge if necessary, and a JDBC network driver when the Java program is running in a network environment (that is, accessing a remote database).
     JDBC specifies a set of object-oriented classes for the programmer to use in building SQL requests. An additional set of classes describes the JDBC driver API. The most common SQL data types, mapped to Java data types, are supported. The API provides for implementation-specific support for Microsoft Transaction Server requests and the ability to commit or roll back to the beginning of a transaction.
     
     Before proceeding, obtain and install the appropriate ODBC driver for the data source to which you want to connect.
     Click Start, and then click Control Panel.

In the Control Panel, double-click Administrative Tools.

In the Administrative Tools dialog box, double-click Data Sources (ODBC).

The ODBC Data Source Administrator dialog box appears.

Click User DSN, System DSN, or File DSN, depending on the type of data source you want to add. For more information, see the section About ODBC data sources.

Click Add.

Select the driver that you want to use, and then click Finish or Next.

If the driver you want is not listed, contact the administrator of the database you are connecting to for information about how to obtain the correct driver.

Follow the instructions and enter the required connection information in any dialog boxes that follow.



Q 3) Describe about Java Beans and BeanBox.
Ans: A Java Bean is a reusable software component that can be manipulated visually in an application builder tool.  The idea is that one can start with a collection of such components, and quickly wire them together to form complex programs without actually writing any new code.
Software components must, in general, adopt standard techniques for interacting with the rest of the world.  For example, all GUI components inherit the java.awt.Component class, which means that one can rely on them to have certain standard methods like paint(), setSize(), etc.  Java Beans are not actually required to inherit a particular base class or implement a particular interface
JavaBeans brings component technology to the Java platform. With the JavaBeans API you can create reuseable, platform-independent components. Using JavaBeans-compliant application builder tools, you can combine these components into applets, applications, or composite components. JavaBean components are known as Beans.
JavaBeans is an object-oriented programming interface from Sun Microsystems that lets you build re-useable applications or program building blocks called components that can be deployed in a network on any major operating system platform. Like Java applets, JavaBeans components (or "Beans") can be used to give World Wide Web pages (or other applications) interactive capabilities such as computing interest rates or varying page content based on user or browser characteristics.

From a user's point-of-view, a component can be a button that you interact with or a small calculating program that gets initiated when you press the button. From a developer's point-of-view, the button component and the calculator component are created separately and can then be used together or in different combinations with other components in different applications or situations.

When the components or Beans are in use, the properties of a Bean (for example, the background color of a window) are visible to other Beans and Beans that haven't "met" before can learn each other's properties dynamically and interact accordingly.

Beans are developed with a Beans Development Kit (BDK) from Sun and can be run on any major operating system platform inside a number of application environments (known as containers), including browsers, word processors, and other applications.
To build a component with JavaBeans, you write language statements using Sun's Java programming language and include JavaBeans statements that describe component properties such as user interface characteristics and events that trigger a bean to communicate with other beans in the same container or elsewhere in the network.
Beans also have persistence, which is a mechanism for storing the state of a component in a safe place. This would allow, for example, a component (bean) to "remember" data that a particular user had already entered in an earlier user session.
JavaBeans gives Java applications the compound document capability that the OpenDoc and ActiveX interfaces already provide.

BeanBox is a test container in BDK. We can use BeanBox to create Application, Applet, and New Beans. We can lay out, edit and interconnect beans visually. That is one of the benefits of Javabeans is the capability for the beans to be used in visual application builder tools.

Before installing BDK, we have to install JDK version 1.1 or later first and then install BDK. There is a "beanbox" directory insidne of BDK (assume "BDK" is a directory for JavaBeans"). BeanBox comes with the batch file, called run.bat in the "beanbox" directory. If we type in "run", it would displays 3 windows:
The first window is Toolbox, it lists all the beans registered for use with BeaBox. We also can write our own beans and add them to this window.
The second window is BeanBox, it is the main container window.
Last window is Propertysheet, it lists the properties associated with the current selected bean. It is responsible for providing the visual editing capabilities of the BeanBox.

This is a basic tool that Sun provides for testing Java Beans.   To run the BeanBox, your computer needs to have access to a BDK installation.  To run the BeanBox, go to the beans/beanbox subdirectory and then type run.  This will bring up three windows:
    The ToolBox window gives you a palette of sample Java Beans to choose from.
    The BeanBox window is a container within which you can visually wire beans together.
    The Properties window allows you to edit the properties of the currently selected Java Bean.
Try a simple example: choose Juggler bean from the ToolBox and drop an instance in the BeanBox window.  Also create two instances of OurButton.  Edit the labels of the buttons to read start and stop using the Properties window.  Now wire the start button to the juggler as follows.  Select the start button, then go to Edit | Events | action | actionPerformed.  Connect the rubber band to the juggler.  You will now see an EventTargetDialog box with a list of Juggler methods that could be invoked when the start button is pressed (these are the methods that either take an ActionEvent as an argument or have no arguments at all.)  Choose startJuggling as the target method and press OK.  The BeanBox now generates an adaptor class to wire the start button to the juggler.  Wire the stop button to the juggler's stopJuggling method in a similar manner.
Now that the program has been designed, you can run it within the BeanBox.  Simply press the start button to start juggling and press the stop button to stop juggling.  If you wish, you can turn your program into an applet by choosing File | MakeApplet in the BeanBox.  This will automatically generate a complete set of files for the applet, which can be run in the appletviewer.  (Do not expect current versions of Netscape and Internet Explorer to work with this applet.)

Let's take a closer look at how the BeanBox works.  On start up, it scans the directory beans/jars for files with the .jar extension that contain Java Beans.  These beans are displayed in the ToolBox window, from where they can be selected and dropped into the BeanBox window.  Next, we edited the labels of the two instances of OurButton.  The BeanBox determined that OurButton has a member named label by looking for setter and getter methods that follow standard naming conventions called design patterns.  If you look at the source code in beans\demo\sunw\demo\buttons\OurButton.java, you will see that OurButton has two methods named
